<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор NTAG216 SmartPoster для Chameleon Ultra</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; margin: 0 auto; max-width: 800px; padding: 20px; background-color: #f4f4f9; }
        h1, h2 { color: #333; }
        .container { background-color: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .form-group { margin-bottom: 15px; }
        label { display: block; font-weight: 600; margin-bottom: 5px; color: #555; }
        input[type="text"], input[type="url"], input[type="number"], select, textarea {
            width: 100%; padding: 10px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box;
        }
        button {
            display: inline-block; background-color: #007bff; color: white; padding: 12px 20px; border: none;
            border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: 600;
        }
        button:hover { background-color: #0056b3; }
        .note { font-size: 0.9em; color: #666; background-color: #e9ecef; padding: 10px; border-radius: 4px; }
        #icon-preview { max-width: 64px; max-height: 64px; border: 1px solid #ccc; display: none; margin-top: 10px;}
    </style>
</head>
<body>

    <div class="container">
        <h1>Генератор NTAG216 SmartPoster</h1>
        <p class="note">Создайте .bin файл для записи на Chameleon Ultra. Файл будет содержать NDEF-сообщение типа SmartPoster.</p>

        <form id="ndef-form">
            <h2>Основная информация (URI)</h2>
            <div class="form-group">
                <label for="uri">URL-адрес (обязательно):</label>
                <input type="url" id="uri" value="https://www.chameleonultra.com/" required>
            </div>

            <h2>Метаданные SmartPoster (необязательно)</h2>
            <div class="form-group">
                <label for="title">Заголовок:</label>
                <input type="text" id="title" placeholder="Например, Официальный сайт">
            </div>
             <div class="form-group">
                <label for="lang">Язык заголовка (BCP 47):</label>
                <input type="text" id="lang" value="ru" placeholder="en, ru, de...">
            </div>
            <div class="form-group">
                <label for="action">Действие:</label>
                <select id="action">
                    <option value="0" selected>Выполнить действие (стандарт)</option>
                    <option value="1">Сохранить для последующего использования</option>
                    <option value="2">Открыть для редактирования</option>
                </select>
            </div>
             <div class="form-group">
                <label for="resource-type">MIME-тип ресурса:</label>
                <input type="text" id="resource-type" placeholder="Например, text/html">
            </div>
            <div class="form-group">
                <label for="resource-size">Размер ресурса (в байтах):</label>
                <input type="number" id="resource-size" placeholder="Например, 15000">
            </div>
            <div class="form-group">
                <label for="icon-file">Файл иконки (PNG/JPEG/GIF, до 8КБ):</label>
                <input type="file" id="icon-file" accept="image/png, image/jpeg, image/gif">
                <img id="icon-preview" alt="Предпросмотр иконки"/>
                <input type="hidden" id="icon-mime-type">
            </div>

            <button type="submit">Сгенерировать .bin файл</button>
        </form>
    </div>

    <script>
        // --- Polyfill для TextEncoder, если нужно ---
        if (typeof TextEncoder === "undefined") {
            window.TextEncoder = function TextEncoder() {};
            TextEncoder.prototype.encode = function(str) {
                var Len = str.length, res = new Uint8Array(Len);
                for (var i = 0; i < Len; i++) {
                    res[i] = str.charCodeAt(i);
                }
                return res;
            };
        }
        const textEncoder = new TextEncoder();

        // --- Обработчик предпросмотра иконки ---
        const iconFileInput = document.getElementById('icon-file');
        const iconPreview = document.getElementById('icon-preview');

        iconFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                if (file.size > 8192) {
                    alert("Размер иконки не должен превышать 8КБ.");
                    iconFileInput.value = '';
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    iconPreview.src = e.target.result;
                    iconPreview.style.display = 'block';
                };
                reader.readAsDataURL(file);
            } else {
                 iconPreview.style.display = 'none';
            }
        });


        // --- Функции для создания NDEF записей ---

        function createUriRecord(uri) {
            const uriPrefixes = [
                "", "http://www.", "https://www.", "http://", "https://", "tel:", "mailto:",
                "ftp://anonymous:anonymous@", "ftp://ftp.", "ftps://", "sftp://", "smb://", "nfs://",
                "ftp://", "dav://", "news:", "telnet://", "imap:", "rtsp://", "urn:", "pop:",
                "sip:", "sips:", "tftp:", "btspp://", "btl2cap://", "btgoep://", "tcpobex://",
                "irdaobex://", "file://", "urn:epc:id:", "urn:epc:tag:", "urn:epc:pat:",
                "urn:epc:raw:", "urn:epc:", "urn:nfc:"
            ];
            let prefixCode = 0;
            for (let i = 1; i < uriPrefixes.length; i++) {
                if (uri.startsWith(uriPrefixes[i])) {
                    prefixCode = i;
                    uri = uri.substring(uriPrefixes[i].length);
                    break;
                }
            }
            const uriBytes = textEncoder.encode(uri);
            const payload = new Uint8Array(1 + uriBytes.length);
            payload[0] = prefixCode;
            payload.set(uriBytes, 1);

            return createNdefRecord(0x01, textEncoder.encode("U"), payload);
        }

        function createTextRecord(text, lang) {
            const langBytes = textEncoder.encode(lang);
            const textBytes = textEncoder.encode(text);
            const status = langBytes.length;
            const payload = new Uint8Array(1 + langBytes.length + textBytes.length);
            payload[0] = status;
            payload.set(langBytes, 1);
            payload.set(textBytes, 1 + langBytes.length);

            return createNdefRecord(0x01, textEncoder.encode("T"), payload);
        }

        function createMimeRecord(mimeType, data) {
            return createNdefRecord(0x02, textEncoder.encode(mimeType), data);
        }

        function createSpSubRecord(type, payload) {
            return createNdefRecord(0x01, textEncoder.encode(type), payload);
        }

        // *** ИСПРАВЛЕННАЯ ФУНКЦИЯ ***
        function createNdefRecord(tnf, type, payload) {
            const isShort = payload.length < 256;
            
            // Header: 1 (flags) + 1 (typeLen) + (1 or 4 for payloadLen) + type.length
            const headerSize = 1 + 1 + (isShort ? 1 : 4) + type.length;
            const header = new Uint8Array(headerSize);
            
            let offset = 0;

            // 1. Flags (TNF, SR). MB/ME флаги устанавливаются позже, при сборке.
            header[offset++] = (tnf & 0x07) | (isShort ? 0x10 : 0x00);

            // 2. Type Length
            header[offset++] = type.length;
            
            // 3. Payload Length
            if (isShort) {
                header[offset++] = payload.length;
            } else {
                header[offset++] = (payload.length >>> 24) & 0xFF;
                header[offset++] = (payload.length >>> 16) & 0xFF;
                header[offset++] = (payload.length >>> 8)  & 0xFF;
                header[offset++] = payload.length & 0xFF;
            }

            // 4. Type
            header.set(type, offset);
            
            const fullRecord = new Uint8Array(header.length + payload.length);
            fullRecord.set(header, 0);
            fullRecord.set(payload, header.length);
            
            return fullRecord; // Возвращаем напрямую массив байтов
        }
        
        // --- Основная логика ---

        document.getElementById('ndef-form').addEventListener('submit', async (e) => {
            e.preventDefault();

            let subRecords = [];

            // 1. URI (обязательно)
            const uri = document.getElementById('uri').value;
            subRecords.push(createUriRecord(uri));

            // 2. Title (опционально)
            const title = document.getElementById('title').value;
            if (title) {
                const lang = document.getElementById('lang').value || 'en';
                subRecords.push(createTextRecord(title, lang));
            }

            // 3. Action (опционально)
            const action = parseInt(document.getElementById('action').value, 10);
            const actionRecordPayload = new Uint8Array([action]);
            subRecords.push(createSpSubRecord('act', actionRecordPayload));


            // 4. Resource Type (опционально)
            const resourceType = document.getElementById('resource-type').value;
            if (resourceType) {
                 subRecords.push(createSpSubRecord('t', textEncoder.encode(resourceType)));
            }

            // 5. Resource Size (опционально)
            const resourceSize = document.getElementById('resource-size').value;
            if (resourceSize) {
                const size = parseInt(resourceSize, 10);
                const sizePayload = new Uint8Array(4);
                new DataView(sizePayload.buffer).setUint32(0, size, false); // Big Endian
                subRecords.push(createSpSubRecord('s', sizePayload));
            }

            // 6. Icon (опционально)
            if (iconFileInput.files[0]) {
                const file = iconFileInput.files[0];
                const mimeType = file.type;
                const arrayBuffer = await file.arrayBuffer();
                const iconData = new Uint8Array(arrayBuffer);
                subRecords.push(createMimeRecord(mimeType, iconData));
            }

            // Объединяем вложенные записи в одну полезную нагрузку
            const spPayloadLength = subRecords.reduce((sum, rec) => sum + rec.length, 0);
            const spPayload = new Uint8Array(spPayloadLength);
            let currentOffset = 0;
            subRecords.forEach((rec, index) => {
                 // Корректируем флаги MB/ME (Message Begin / Message End) для вложенных записей
                 if (index === 0) rec[0] |= 0x80; // Устанавливаем флаг MB для первой записи
                 if (index === subRecords.length - 1) rec[0] |= 0x40; // Устанавливаем флаг ME для последней
                 
                 spPayload.set(rec, currentOffset);
                 currentOffset += rec.length;
            });
            
            // Создаем основную запись SmartPoster
            const spRecordBytes = createNdefRecord(0x01, textEncoder.encode("Sp"), spPayload);
            // *** ИСПРАВЛЕНИЕ: Устанавливаем флаги MB и ME для основной записи, т.к. она одна в сообщении ***
            spRecordBytes[0] |= 0xC0; // 0xC0 = 0b11000000 (MB=1, ME=1)
            
            // Формируем TLV для NDEF сообщения
            const ndefMessage = new Uint8Array(2 + spRecordBytes.length + 1);
            ndefMessage[0] = 0x03; // NDEF Message TLV
            ndefMessage[1] = spRecordBytes.length; // Length
            ndefMessage.set(spRecordBytes, 2);
            ndefMessage[2 + spRecordBytes.length] = 0xFE; // Terminator TLV

            // Создаем полный дамп памяти NTAG216 (924 байта)
            const ntag216Memory = new Uint8Array(924).fill(0);
            
            // Записываем стандартный заголовок NTAG216 (UID, lock bytes и т.д.)
            // Chameleon их проигнорирует или перезапишет реальными.
            ntag216Memory.set([0x04, 0x00, 0x00, 0x00], 0); // UID0-3, где 0x04 - производитель NXP
            ntag216Memory.set([0x00, 0x00, 0x00, 0x00], 4); // UID4-6, BCC1
            ntag216Memory.set([0x00, 0x00, 0x48, 0x00], 8); // Internal, Lock bytes, 0x48 - статичные lock bits

            // Записываем Capability Container (CC) в страницу 3 (адрес 0x0C)
            // E1 10 6D 00: NDEF, v1.0, 872 байта данных (0x6D * 8), чтение/запись без пароля
            const memorySizeInBytes = 872;
            const ccPage = [0xE1, 0x10, Math.floor(memorySizeInBytes / 8), 0x00];
            ntag216Memory.set(ccPage, 12);
            
            // Записываем NDEF-сообщение, начиная со страницы 4 (адрес 0x10)
            if (ndefMessage.length > memorySizeInBytes) {
                alert(`Ошибка: Размер NDEF сообщения (${ndefMessage.length} байт) превышает доступную память (${memorySizeInBytes} байт).`);
                return;
            }
            ntag216Memory.set(ndefMessage, 16);

            // Создаем и скачиваем .bin файл
            const blob = new Blob([ntag216Memory], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ntag216.bin';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>
